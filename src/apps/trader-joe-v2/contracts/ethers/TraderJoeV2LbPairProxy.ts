/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface TraderJoeV2LbPairProxyInterface extends utils.Interface {
  functions: {
    'approveForAll(address,bool)': FunctionFragment;
    'balanceOf(address,uint256)': FunctionFragment;
    'balanceOfBatch(address[],uint256[])': FunctionFragment;
    'batchTransferFrom(address,address,uint256[],uint256[])': FunctionFragment;
    'burn(address,address,uint256[],uint256[])': FunctionFragment;
    'collectProtocolFees()': FunctionFragment;
    'flashLoan(address,bytes32,bytes)': FunctionFragment;
    'forceDecay()': FunctionFragment;
    'getActiveId()': FunctionFragment;
    'getBin(uint24)': FunctionFragment;
    'getBinStep()': FunctionFragment;
    'getFactory()': FunctionFragment;
    'getIdFromPrice(uint256)': FunctionFragment;
    'getNextNonEmptyBin(bool,uint24)': FunctionFragment;
    'getOracleParameters()': FunctionFragment;
    'getOracleSampleAt(uint40)': FunctionFragment;
    'getPriceFromId(uint24)': FunctionFragment;
    'getProtocolFees()': FunctionFragment;
    'getReserves()': FunctionFragment;
    'getStaticFeeParameters()': FunctionFragment;
    'getSwapIn(uint128,bool)': FunctionFragment;
    'getSwapOut(uint128,bool)': FunctionFragment;
    'getTokenX()': FunctionFragment;
    'getTokenY()': FunctionFragment;
    'getVariableFeeParameters()': FunctionFragment;
    'increaseOracleLength(uint16)': FunctionFragment;
    'initialize(uint16,uint16,uint16,uint16,uint24,uint16,uint24,uint24)': FunctionFragment;
    'isApprovedForAll(address,address)': FunctionFragment;
    'mint(address,bytes32[],address)': FunctionFragment;
    'name()': FunctionFragment;
    'setStaticFeeParameters(uint16,uint16,uint16,uint16,uint24,uint16,uint24)': FunctionFragment;
    'swap(bool,address)': FunctionFragment;
    'symbol()': FunctionFragment;
    'totalSupply(uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'approveForAll'
      | 'balanceOf'
      | 'balanceOfBatch'
      | 'batchTransferFrom'
      | 'burn'
      | 'collectProtocolFees'
      | 'flashLoan'
      | 'forceDecay'
      | 'getActiveId'
      | 'getBin'
      | 'getBinStep'
      | 'getFactory'
      | 'getIdFromPrice'
      | 'getNextNonEmptyBin'
      | 'getOracleParameters'
      | 'getOracleSampleAt'
      | 'getPriceFromId'
      | 'getProtocolFees'
      | 'getReserves'
      | 'getStaticFeeParameters'
      | 'getSwapIn'
      | 'getSwapOut'
      | 'getTokenX'
      | 'getTokenY'
      | 'getVariableFeeParameters'
      | 'increaseOracleLength'
      | 'initialize'
      | 'isApprovedForAll'
      | 'mint'
      | 'name'
      | 'setStaticFeeParameters'
      | 'swap'
      | 'symbol'
      | 'totalSupply',
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'approveForAll',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOf',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOfBatch',
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'batchTransferFrom',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'burn',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
    ],
  ): string;
  encodeFunctionData(functionFragment: 'collectProtocolFees', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'flashLoan',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(functionFragment: 'forceDecay', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getActiveId', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getBin', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getBinStep', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getFactory', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getIdFromPrice', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'getNextNonEmptyBin',
    values: [PromiseOrValue<boolean>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: 'getOracleParameters', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getOracleSampleAt', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getPriceFromId', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getProtocolFees', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getReserves', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getStaticFeeParameters', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getSwapIn',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getSwapOut',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: 'getTokenX', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getTokenY', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getVariableFeeParameters', values?: undefined): string;
  encodeFunctionData(functionFragment: 'increaseOracleLength', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'isApprovedForAll',
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'mint',
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>[], PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setStaticFeeParameters',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'swap', values: [PromiseOrValue<boolean>, PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalSupply', values: [PromiseOrValue<BigNumberish>]): string;

  decodeFunctionResult(functionFragment: 'approveForAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balanceOfBatch', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'batchTransferFrom', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burn', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'collectProtocolFees', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'flashLoan', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'forceDecay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getActiveId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getBinStep', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getFactory', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getIdFromPrice', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getNextNonEmptyBin', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getOracleParameters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getOracleSampleAt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPriceFromId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getProtocolFees', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getReserves', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getStaticFeeParameters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSwapIn', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSwapOut', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getTokenX', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getTokenY', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getVariableFeeParameters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'increaseOracleLength', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isApprovedForAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'mint', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setStaticFeeParameters', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'swap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;

  events: {
    'ApprovalForAll(address,address,bool)': EventFragment;
    'CollectedProtocolFees(address,bytes32)': EventFragment;
    'CompositionFees(address,uint24,bytes32,bytes32)': EventFragment;
    'DepositedToBins(address,address,uint256[],bytes32[])': EventFragment;
    'FlashLoan(address,address,uint24,bytes32,bytes32,bytes32)': EventFragment;
    'ForcedDecay(address,uint24,uint24)': EventFragment;
    'OracleLengthIncreased(address,uint16)': EventFragment;
    'StaticFeeParametersSet(address,uint16,uint16,uint16,uint16,uint24,uint16,uint24)': EventFragment;
    'Swap(address,address,uint24,bytes32,bytes32,uint24,bytes32,bytes32)': EventFragment;
    'TransferBatch(address,address,address,uint256[],uint256[])': EventFragment;
    'WithdrawnFromBins(address,address,uint256[],bytes32[])': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CollectedProtocolFees'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CompositionFees'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DepositedToBins'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'FlashLoan'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ForcedDecay'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OracleLengthIncreased'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'StaticFeeParametersSet'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Swap'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferBatch'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WithdrawnFromBins'): EventFragment;
}

export interface ApprovalForAllEventObject {
  account: string;
  sender: string;
  approved: boolean;
}
export type ApprovalForAllEvent = TypedEvent<[string, string, boolean], ApprovalForAllEventObject>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export interface CollectedProtocolFeesEventObject {
  feeRecipient: string;
  protocolFees: string;
}
export type CollectedProtocolFeesEvent = TypedEvent<[string, string], CollectedProtocolFeesEventObject>;

export type CollectedProtocolFeesEventFilter = TypedEventFilter<CollectedProtocolFeesEvent>;

export interface CompositionFeesEventObject {
  sender: string;
  id: number;
  totalFees: string;
  protocolFees: string;
}
export type CompositionFeesEvent = TypedEvent<[string, number, string, string], CompositionFeesEventObject>;

export type CompositionFeesEventFilter = TypedEventFilter<CompositionFeesEvent>;

export interface DepositedToBinsEventObject {
  sender: string;
  to: string;
  ids: BigNumber[];
  amounts: string[];
}
export type DepositedToBinsEvent = TypedEvent<[string, string, BigNumber[], string[]], DepositedToBinsEventObject>;

export type DepositedToBinsEventFilter = TypedEventFilter<DepositedToBinsEvent>;

export interface FlashLoanEventObject {
  sender: string;
  receiver: string;
  activeId: number;
  amounts: string;
  totalFees: string;
  protocolFees: string;
}
export type FlashLoanEvent = TypedEvent<[string, string, number, string, string, string], FlashLoanEventObject>;

export type FlashLoanEventFilter = TypedEventFilter<FlashLoanEvent>;

export interface ForcedDecayEventObject {
  sender: string;
  idReference: number;
  volatilityReference: number;
}
export type ForcedDecayEvent = TypedEvent<[string, number, number], ForcedDecayEventObject>;

export type ForcedDecayEventFilter = TypedEventFilter<ForcedDecayEvent>;

export interface OracleLengthIncreasedEventObject {
  sender: string;
  oracleLength: number;
}
export type OracleLengthIncreasedEvent = TypedEvent<[string, number], OracleLengthIncreasedEventObject>;

export type OracleLengthIncreasedEventFilter = TypedEventFilter<OracleLengthIncreasedEvent>;

export interface StaticFeeParametersSetEventObject {
  sender: string;
  baseFactor: number;
  filterPeriod: number;
  decayPeriod: number;
  reductionFactor: number;
  variableFeeControl: number;
  protocolShare: number;
  maxVolatilityAccumulator: number;
}
export type StaticFeeParametersSetEvent = TypedEvent<
  [string, number, number, number, number, number, number, number],
  StaticFeeParametersSetEventObject
>;

export type StaticFeeParametersSetEventFilter = TypedEventFilter<StaticFeeParametersSetEvent>;

export interface SwapEventObject {
  sender: string;
  to: string;
  id: number;
  amountsIn: string;
  amountsOut: string;
  volatilityAccumulator: number;
  totalFees: string;
  protocolFees: string;
}
export type SwapEvent = TypedEvent<[string, string, number, string, string, number, string, string], SwapEventObject>;

export type SwapEventFilter = TypedEventFilter<SwapEvent>;

export interface TransferBatchEventObject {
  sender: string;
  from: string;
  to: string;
  ids: BigNumber[];
  amounts: BigNumber[];
}
export type TransferBatchEvent = TypedEvent<
  [string, string, string, BigNumber[], BigNumber[]],
  TransferBatchEventObject
>;

export type TransferBatchEventFilter = TypedEventFilter<TransferBatchEvent>;

export interface WithdrawnFromBinsEventObject {
  sender: string;
  to: string;
  ids: BigNumber[];
  amounts: string[];
}
export type WithdrawnFromBinsEvent = TypedEvent<[string, string, BigNumber[], string[]], WithdrawnFromBinsEventObject>;

export type WithdrawnFromBinsEventFilter = TypedEventFilter<WithdrawnFromBinsEvent>;

export interface TraderJoeV2LbPairProxy extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TraderJoeV2LbPairProxyInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    approveForAll(
      spender: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber]>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<[BigNumber[]] & { batchBalances: BigNumber[] }>;

    batchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    burn(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amountsToBurn: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    collectProtocolFees(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    flashLoan(
      receiver: PromiseOrValue<string>,
      amounts: PromiseOrValue<BytesLike>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    forceDecay(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    getActiveId(overrides?: CallOverrides): Promise<[number] & { activeId: number }>;

    getBin(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        binReserveX: BigNumber;
        binReserveY: BigNumber;
      }
    >;

    getBinStep(overrides?: CallOverrides): Promise<[number]>;

    getFactory(overrides?: CallOverrides): Promise<[string] & { factory: string }>;

    getIdFromPrice(price: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[number] & { id: number }>;

    getNextNonEmptyBin(
      swapForY: PromiseOrValue<boolean>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[number] & { nextId: number }>;

    getOracleParameters(overrides?: CallOverrides): Promise<
      [number, number, number, number, number] & {
        sampleLifetime: number;
        size: number;
        activeSize: number;
        lastUpdated: number;
        firstTimestamp: number;
      }
    >;

    getOracleSampleAt(
      lookupTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        cumulativeId: BigNumber;
        cumulativeVolatility: BigNumber;
        cumulativeBinCrossed: BigNumber;
      }
    >;

    getPriceFromId(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { price: BigNumber }>;

    getProtocolFees(overrides?: CallOverrides): Promise<
      [BigNumber, BigNumber] & {
        protocolFeeX: BigNumber;
        protocolFeeY: BigNumber;
      }
    >;

    getReserves(
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { reserveX: BigNumber; reserveY: BigNumber }>;

    getStaticFeeParameters(overrides?: CallOverrides): Promise<
      [number, number, number, number, number, number, number] & {
        baseFactor: number;
        filterPeriod: number;
        decayPeriod: number;
        reductionFactor: number;
        variableFeeControl: number;
        protocolShare: number;
        maxVolatilityAccumulator: number;
      }
    >;

    getSwapIn(
      amountOut: PromiseOrValue<BigNumberish>,
      swapForY: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amountIn: BigNumber;
        amountOutLeft: BigNumber;
        fee: BigNumber;
      }
    >;

    getSwapOut(
      amountIn: PromiseOrValue<BigNumberish>,
      swapForY: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amountInLeft: BigNumber;
        amountOut: BigNumber;
        fee: BigNumber;
      }
    >;

    getTokenX(overrides?: CallOverrides): Promise<[string] & { tokenX: string }>;

    getTokenY(overrides?: CallOverrides): Promise<[string] & { tokenY: string }>;

    getVariableFeeParameters(overrides?: CallOverrides): Promise<
      [number, number, number, number] & {
        volatilityAccumulator: number;
        volatilityReference: number;
        idReference: number;
        timeOfLastUpdate: number;
      }
    >;

    increaseOracleLength(
      newLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    initialize(
      baseFactor: PromiseOrValue<BigNumberish>,
      filterPeriod: PromiseOrValue<BigNumberish>,
      decayPeriod: PromiseOrValue<BigNumberish>,
      reductionFactor: PromiseOrValue<BigNumberish>,
      variableFeeControl: PromiseOrValue<BigNumberish>,
      protocolShare: PromiseOrValue<BigNumberish>,
      maxVolatilityAccumulator: PromiseOrValue<BigNumberish>,
      activeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    mint(
      to: PromiseOrValue<string>,
      liquidityConfigs: PromiseOrValue<BytesLike>[],
      refundTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<[string]>;

    setStaticFeeParameters(
      baseFactor: PromiseOrValue<BigNumberish>,
      filterPeriod: PromiseOrValue<BigNumberish>,
      decayPeriod: PromiseOrValue<BigNumberish>,
      reductionFactor: PromiseOrValue<BigNumberish>,
      variableFeeControl: PromiseOrValue<BigNumberish>,
      protocolShare: PromiseOrValue<BigNumberish>,
      maxVolatilityAccumulator: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    swap(
      swapForY: PromiseOrValue<boolean>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    totalSupply(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  approveForAll(
    spender: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  balanceOf(
    account: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  balanceOfBatch(
    accounts: PromiseOrValue<string>[],
    ids: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides,
  ): Promise<BigNumber[]>;

  batchTransferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    ids: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  burn(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    ids: PromiseOrValue<BigNumberish>[],
    amountsToBurn: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  collectProtocolFees(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  flashLoan(
    receiver: PromiseOrValue<string>,
    amounts: PromiseOrValue<BytesLike>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  forceDecay(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  getActiveId(overrides?: CallOverrides): Promise<number>;

  getBin(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { binReserveX: BigNumber; binReserveY: BigNumber }>;

  getBinStep(overrides?: CallOverrides): Promise<number>;

  getFactory(overrides?: CallOverrides): Promise<string>;

  getIdFromPrice(price: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<number>;

  getNextNonEmptyBin(
    swapForY: PromiseOrValue<boolean>,
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<number>;

  getOracleParameters(overrides?: CallOverrides): Promise<
    [number, number, number, number, number] & {
      sampleLifetime: number;
      size: number;
      activeSize: number;
      lastUpdated: number;
      firstTimestamp: number;
    }
  >;

  getOracleSampleAt(
    lookupTimestamp: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      cumulativeId: BigNumber;
      cumulativeVolatility: BigNumber;
      cumulativeBinCrossed: BigNumber;
    }
  >;

  getPriceFromId(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  getProtocolFees(overrides?: CallOverrides): Promise<
    [BigNumber, BigNumber] & {
      protocolFeeX: BigNumber;
      protocolFeeY: BigNumber;
    }
  >;

  getReserves(
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { reserveX: BigNumber; reserveY: BigNumber }>;

  getStaticFeeParameters(overrides?: CallOverrides): Promise<
    [number, number, number, number, number, number, number] & {
      baseFactor: number;
      filterPeriod: number;
      decayPeriod: number;
      reductionFactor: number;
      variableFeeControl: number;
      protocolShare: number;
      maxVolatilityAccumulator: number;
    }
  >;

  getSwapIn(
    amountOut: PromiseOrValue<BigNumberish>,
    swapForY: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      amountIn: BigNumber;
      amountOutLeft: BigNumber;
      fee: BigNumber;
    }
  >;

  getSwapOut(
    amountIn: PromiseOrValue<BigNumberish>,
    swapForY: PromiseOrValue<boolean>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      amountInLeft: BigNumber;
      amountOut: BigNumber;
      fee: BigNumber;
    }
  >;

  getTokenX(overrides?: CallOverrides): Promise<string>;

  getTokenY(overrides?: CallOverrides): Promise<string>;

  getVariableFeeParameters(overrides?: CallOverrides): Promise<
    [number, number, number, number] & {
      volatilityAccumulator: number;
      volatilityReference: number;
      idReference: number;
      timeOfLastUpdate: number;
    }
  >;

  increaseOracleLength(
    newLength: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  initialize(
    baseFactor: PromiseOrValue<BigNumberish>,
    filterPeriod: PromiseOrValue<BigNumberish>,
    decayPeriod: PromiseOrValue<BigNumberish>,
    reductionFactor: PromiseOrValue<BigNumberish>,
    variableFeeControl: PromiseOrValue<BigNumberish>,
    protocolShare: PromiseOrValue<BigNumberish>,
    maxVolatilityAccumulator: PromiseOrValue<BigNumberish>,
    activeId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isApprovedForAll(
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  mint(
    to: PromiseOrValue<string>,
    liquidityConfigs: PromiseOrValue<BytesLike>[],
    refundTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  setStaticFeeParameters(
    baseFactor: PromiseOrValue<BigNumberish>,
    filterPeriod: PromiseOrValue<BigNumberish>,
    decayPeriod: PromiseOrValue<BigNumberish>,
    reductionFactor: PromiseOrValue<BigNumberish>,
    variableFeeControl: PromiseOrValue<BigNumberish>,
    protocolShare: PromiseOrValue<BigNumberish>,
    maxVolatilityAccumulator: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  swap(
    swapForY: PromiseOrValue<boolean>,
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  symbol(overrides?: CallOverrides): Promise<string>;

  totalSupply(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    approveForAll(
      spender: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<BigNumber[]>;

    batchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    burn(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amountsToBurn: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<string[]>;

    collectProtocolFees(overrides?: CallOverrides): Promise<string>;

    flashLoan(
      receiver: PromiseOrValue<string>,
      amounts: PromiseOrValue<BytesLike>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    forceDecay(overrides?: CallOverrides): Promise<void>;

    getActiveId(overrides?: CallOverrides): Promise<number>;

    getBin(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber] & {
        binReserveX: BigNumber;
        binReserveY: BigNumber;
      }
    >;

    getBinStep(overrides?: CallOverrides): Promise<number>;

    getFactory(overrides?: CallOverrides): Promise<string>;

    getIdFromPrice(price: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<number>;

    getNextNonEmptyBin(
      swapForY: PromiseOrValue<boolean>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<number>;

    getOracleParameters(overrides?: CallOverrides): Promise<
      [number, number, number, number, number] & {
        sampleLifetime: number;
        size: number;
        activeSize: number;
        lastUpdated: number;
        firstTimestamp: number;
      }
    >;

    getOracleSampleAt(
      lookupTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        cumulativeId: BigNumber;
        cumulativeVolatility: BigNumber;
        cumulativeBinCrossed: BigNumber;
      }
    >;

    getPriceFromId(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getProtocolFees(overrides?: CallOverrides): Promise<
      [BigNumber, BigNumber] & {
        protocolFeeX: BigNumber;
        protocolFeeY: BigNumber;
      }
    >;

    getReserves(
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { reserveX: BigNumber; reserveY: BigNumber }>;

    getStaticFeeParameters(overrides?: CallOverrides): Promise<
      [number, number, number, number, number, number, number] & {
        baseFactor: number;
        filterPeriod: number;
        decayPeriod: number;
        reductionFactor: number;
        variableFeeControl: number;
        protocolShare: number;
        maxVolatilityAccumulator: number;
      }
    >;

    getSwapIn(
      amountOut: PromiseOrValue<BigNumberish>,
      swapForY: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amountIn: BigNumber;
        amountOutLeft: BigNumber;
        fee: BigNumber;
      }
    >;

    getSwapOut(
      amountIn: PromiseOrValue<BigNumberish>,
      swapForY: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amountInLeft: BigNumber;
        amountOut: BigNumber;
        fee: BigNumber;
      }
    >;

    getTokenX(overrides?: CallOverrides): Promise<string>;

    getTokenY(overrides?: CallOverrides): Promise<string>;

    getVariableFeeParameters(overrides?: CallOverrides): Promise<
      [number, number, number, number] & {
        volatilityAccumulator: number;
        volatilityReference: number;
        idReference: number;
        timeOfLastUpdate: number;
      }
    >;

    increaseOracleLength(newLength: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    initialize(
      baseFactor: PromiseOrValue<BigNumberish>,
      filterPeriod: PromiseOrValue<BigNumberish>,
      decayPeriod: PromiseOrValue<BigNumberish>,
      reductionFactor: PromiseOrValue<BigNumberish>,
      variableFeeControl: PromiseOrValue<BigNumberish>,
      protocolShare: PromiseOrValue<BigNumberish>,
      maxVolatilityAccumulator: PromiseOrValue<BigNumberish>,
      activeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    mint(
      to: PromiseOrValue<string>,
      liquidityConfigs: PromiseOrValue<BytesLike>[],
      refundTo: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [string, string, BigNumber[]] & {
        amountsReceived: string;
        amountsLeft: string;
        liquidityMinted: BigNumber[];
      }
    >;

    name(overrides?: CallOverrides): Promise<string>;

    setStaticFeeParameters(
      baseFactor: PromiseOrValue<BigNumberish>,
      filterPeriod: PromiseOrValue<BigNumberish>,
      decayPeriod: PromiseOrValue<BigNumberish>,
      reductionFactor: PromiseOrValue<BigNumberish>,
      variableFeeControl: PromiseOrValue<BigNumberish>,
      protocolShare: PromiseOrValue<BigNumberish>,
      maxVolatilityAccumulator: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    swap(swapForY: PromiseOrValue<boolean>, to: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;

    symbol(overrides?: CallOverrides): Promise<string>;

    totalSupply(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    'ApprovalForAll(address,address,bool)'(
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
      approved?: null,
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
      approved?: null,
    ): ApprovalForAllEventFilter;

    'CollectedProtocolFees(address,bytes32)'(
      feeRecipient?: PromiseOrValue<string> | null,
      protocolFees?: null,
    ): CollectedProtocolFeesEventFilter;
    CollectedProtocolFees(
      feeRecipient?: PromiseOrValue<string> | null,
      protocolFees?: null,
    ): CollectedProtocolFeesEventFilter;

    'CompositionFees(address,uint24,bytes32,bytes32)'(
      sender?: PromiseOrValue<string> | null,
      id?: null,
      totalFees?: null,
      protocolFees?: null,
    ): CompositionFeesEventFilter;
    CompositionFees(
      sender?: PromiseOrValue<string> | null,
      id?: null,
      totalFees?: null,
      protocolFees?: null,
    ): CompositionFeesEventFilter;

    'DepositedToBins(address,address,uint256[],bytes32[])'(
      sender?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      amounts?: null,
    ): DepositedToBinsEventFilter;
    DepositedToBins(
      sender?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      amounts?: null,
    ): DepositedToBinsEventFilter;

    'FlashLoan(address,address,uint24,bytes32,bytes32,bytes32)'(
      sender?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      activeId?: null,
      amounts?: null,
      totalFees?: null,
      protocolFees?: null,
    ): FlashLoanEventFilter;
    FlashLoan(
      sender?: PromiseOrValue<string> | null,
      receiver?: PromiseOrValue<string> | null,
      activeId?: null,
      amounts?: null,
      totalFees?: null,
      protocolFees?: null,
    ): FlashLoanEventFilter;

    'ForcedDecay(address,uint24,uint24)'(
      sender?: PromiseOrValue<string> | null,
      idReference?: null,
      volatilityReference?: null,
    ): ForcedDecayEventFilter;
    ForcedDecay(
      sender?: PromiseOrValue<string> | null,
      idReference?: null,
      volatilityReference?: null,
    ): ForcedDecayEventFilter;

    'OracleLengthIncreased(address,uint16)'(
      sender?: PromiseOrValue<string> | null,
      oracleLength?: null,
    ): OracleLengthIncreasedEventFilter;
    OracleLengthIncreased(
      sender?: PromiseOrValue<string> | null,
      oracleLength?: null,
    ): OracleLengthIncreasedEventFilter;

    'StaticFeeParametersSet(address,uint16,uint16,uint16,uint16,uint24,uint16,uint24)'(
      sender?: PromiseOrValue<string> | null,
      baseFactor?: null,
      filterPeriod?: null,
      decayPeriod?: null,
      reductionFactor?: null,
      variableFeeControl?: null,
      protocolShare?: null,
      maxVolatilityAccumulator?: null,
    ): StaticFeeParametersSetEventFilter;
    StaticFeeParametersSet(
      sender?: PromiseOrValue<string> | null,
      baseFactor?: null,
      filterPeriod?: null,
      decayPeriod?: null,
      reductionFactor?: null,
      variableFeeControl?: null,
      protocolShare?: null,
      maxVolatilityAccumulator?: null,
    ): StaticFeeParametersSetEventFilter;

    'Swap(address,address,uint24,bytes32,bytes32,uint24,bytes32,bytes32)'(
      sender?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      id?: null,
      amountsIn?: null,
      amountsOut?: null,
      volatilityAccumulator?: null,
      totalFees?: null,
      protocolFees?: null,
    ): SwapEventFilter;
    Swap(
      sender?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      id?: null,
      amountsIn?: null,
      amountsOut?: null,
      volatilityAccumulator?: null,
      totalFees?: null,
      protocolFees?: null,
    ): SwapEventFilter;

    'TransferBatch(address,address,address,uint256[],uint256[])'(
      sender?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      amounts?: null,
    ): TransferBatchEventFilter;
    TransferBatch(
      sender?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      amounts?: null,
    ): TransferBatchEventFilter;

    'WithdrawnFromBins(address,address,uint256[],bytes32[])'(
      sender?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      amounts?: null,
    ): WithdrawnFromBinsEventFilter;
    WithdrawnFromBins(
      sender?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      amounts?: null,
    ): WithdrawnFromBinsEventFilter;
  };

  estimateGas: {
    approveForAll(
      spender: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    batchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    burn(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amountsToBurn: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    collectProtocolFees(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    flashLoan(
      receiver: PromiseOrValue<string>,
      amounts: PromiseOrValue<BytesLike>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    forceDecay(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    getActiveId(overrides?: CallOverrides): Promise<BigNumber>;

    getBin(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getBinStep(overrides?: CallOverrides): Promise<BigNumber>;

    getFactory(overrides?: CallOverrides): Promise<BigNumber>;

    getIdFromPrice(price: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getNextNonEmptyBin(
      swapForY: PromiseOrValue<boolean>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getOracleParameters(overrides?: CallOverrides): Promise<BigNumber>;

    getOracleSampleAt(lookupTimestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getPriceFromId(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    getProtocolFees(overrides?: CallOverrides): Promise<BigNumber>;

    getReserves(overrides?: CallOverrides): Promise<BigNumber>;

    getStaticFeeParameters(overrides?: CallOverrides): Promise<BigNumber>;

    getSwapIn(
      amountOut: PromiseOrValue<BigNumberish>,
      swapForY: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getSwapOut(
      amountIn: PromiseOrValue<BigNumberish>,
      swapForY: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getTokenX(overrides?: CallOverrides): Promise<BigNumber>;

    getTokenY(overrides?: CallOverrides): Promise<BigNumber>;

    getVariableFeeParameters(overrides?: CallOverrides): Promise<BigNumber>;

    increaseOracleLength(
      newLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    initialize(
      baseFactor: PromiseOrValue<BigNumberish>,
      filterPeriod: PromiseOrValue<BigNumberish>,
      decayPeriod: PromiseOrValue<BigNumberish>,
      reductionFactor: PromiseOrValue<BigNumberish>,
      variableFeeControl: PromiseOrValue<BigNumberish>,
      protocolShare: PromiseOrValue<BigNumberish>,
      maxVolatilityAccumulator: PromiseOrValue<BigNumberish>,
      activeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    mint(
      to: PromiseOrValue<string>,
      liquidityConfigs: PromiseOrValue<BytesLike>[],
      refundTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    setStaticFeeParameters(
      baseFactor: PromiseOrValue<BigNumberish>,
      filterPeriod: PromiseOrValue<BigNumberish>,
      decayPeriod: PromiseOrValue<BigNumberish>,
      reductionFactor: PromiseOrValue<BigNumberish>,
      variableFeeControl: PromiseOrValue<BigNumberish>,
      protocolShare: PromiseOrValue<BigNumberish>,
      maxVolatilityAccumulator: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    swap(
      swapForY: PromiseOrValue<boolean>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    approveForAll(
      spender: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    batchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    burn(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amountsToBurn: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    collectProtocolFees(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    flashLoan(
      receiver: PromiseOrValue<string>,
      amounts: PromiseOrValue<BytesLike>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    forceDecay(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    getActiveId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBin(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBinStep(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getFactory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getIdFromPrice(price: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNextNonEmptyBin(
      swapForY: PromiseOrValue<boolean>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getOracleParameters(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getOracleSampleAt(
      lookupTimestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getPriceFromId(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getProtocolFees(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStaticFeeParameters(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getSwapIn(
      amountOut: PromiseOrValue<BigNumberish>,
      swapForY: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getSwapOut(
      amountIn: PromiseOrValue<BigNumberish>,
      swapForY: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getTokenX(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTokenY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getVariableFeeParameters(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    increaseOracleLength(
      newLength: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    initialize(
      baseFactor: PromiseOrValue<BigNumberish>,
      filterPeriod: PromiseOrValue<BigNumberish>,
      decayPeriod: PromiseOrValue<BigNumberish>,
      reductionFactor: PromiseOrValue<BigNumberish>,
      variableFeeControl: PromiseOrValue<BigNumberish>,
      protocolShare: PromiseOrValue<BigNumberish>,
      maxVolatilityAccumulator: PromiseOrValue<BigNumberish>,
      activeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isApprovedForAll(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    mint(
      to: PromiseOrValue<string>,
      liquidityConfigs: PromiseOrValue<BytesLike>[],
      refundTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setStaticFeeParameters(
      baseFactor: PromiseOrValue<BigNumberish>,
      filterPeriod: PromiseOrValue<BigNumberish>,
      decayPeriod: PromiseOrValue<BigNumberish>,
      reductionFactor: PromiseOrValue<BigNumberish>,
      variableFeeControl: PromiseOrValue<BigNumberish>,
      protocolShare: PromiseOrValue<BigNumberish>,
      maxVolatilityAccumulator: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    swap(
      swapForY: PromiseOrValue<boolean>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(id: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
